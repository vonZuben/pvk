
- [x] change the raw_flags! macro in the generated bitmask_traits to flags_from_type! (also const_enum! to enum_from_type!)

- [x] make better way to make enum value from the respective type

- [x] make better way to make bitmask value from the respective type

- [x] change verify2 macro verify_vuids! ??

- [x] fix bitflags! macro to allow full path name rather than just ident
    (I think I fixed it, but I'll come back to it later if I find a need to)

- [x] change EnumeratorStorage to ArrayStorage and query_len to allocate

- [ ] EnumeratorStorage Result should be dyn Error??

- [ ] make proper ErrorTypes for Instance and Device creation

##TODO
    I think the whole api needs Errors more carefully considered

- [ ] QueueFamilies::configure_create_info should return Result??

- [ ] ~~ensure selected versions for instance/device are actually supported~~ (actually, I think this may not be necessary, since the instance should just fail to create in a safe way)

- [x] make zero bitflags safe again, since we just do verification at use site if zero is not allowed

- [x] info structs obtained from handles such as PhysicalDevice should borrow the handle to ensure they are tied to the same scope as the handle

- [x] combine feature and extension commands in the Device and Instance configs (if an extension command is promoted, then the actual function pointer won't be in the extension commands anymore and the GetComments impl will not work)

---
- [ ] handles like Device require child objects to be destroyed before they are destroyed. There is a borrow relationship for child objects, and the Drop impl calls appropriate Destroy method. However, objects can be forgotten and never destroyed. How bad is this really? can we ensure objects are Destroyed and not forgotten (maybe using the scope)?
###TODO
    FYI this is only a problem because a user can forget() a handle and it will not be dropped/destroyed
    I should test if not destroying child objects before destroying Device can cause problems (memory issue? crash?).
    If the only problem is leaking resources, then it is fine as far as "Rust" api goes, even if it violates the Vulkan specs

Vulkan spec (https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html) says:
The lifetime of each of these objects is bound by the lifetime of the VkDevice object. Therefore, <u>to avoid resource leaks</u>, it is critical that an application explicitly free all of these resources prior to calling vkDestroyDevice.

I think it is __NOT__ unsound if objects are not destroyed, as long as they are not used later
since this is a problem with "forgetting" objects, it should not be a soundness issue

---

- [ ] ~~fix so krs_hlist::Get or vk_safe_sys::GetCommand is not needed to be imported directly (since it is part of the bound it should be inherent)~~
####FYI
I am not sure it is possible. It is also not worth my time since it is only for internal implementation details

- [ ] ~~in safe method wrappers, separate the step of getting the fptr, and calling the fptr~~
        I think there is no real point