- [x] fix Display implementations for extension emums (that have extension suffix)
        This also fixes all shorthand generation for enumeration variants

- [x] consider how handles are passed in to functions and structs (somewhat inconvenient to need to manually get handle from handle owner)
        simply used into()

- [x] consider how to incorporate VkResult into return type for commands
        made custom error type a way to convert Vulkan error type thereto
        change the Vulkan error type name to VkResultRaw and custom error type name to VkResult

- [?] consider how to deal with "sudo" optional types, such as in VkWriteDescriptorSet
        maybe this is out of scope for this library

- [x] - still need device code build entry code for creating instance, and also build code for properly create Devices (load Device commands)


- [x] impl Debug for all generated types

- [x] create some kind of 'Entry' code for loading commands that do not take dispatchable handles

- [x] remember to deal with comands that still arn't generated (e.g. because they have a void param)
        I forgot I dealt with this a long time ago (around 11/5/2020 and 11/7/2020)

- [x] figure out how to represent void
        (some solution for this was made, but there may be room to improve this still)

- [x] IMPORTANT how to deal with HandleOwners when we don't own the handle
        e.g. we only "get" swapchain images (we do not create them and we should not destroy them)
        IDEA, HandleOwners should only be used from "create" commands. All other commands only return a basic handle.
                SUB PROBLEM: how to deal with CommandBuffers which still want to have command dispatch
                also PhysicalDevice
                also Queue
        FIXED: solution, HandleOwners have an 'Own' state that can be Owned, ManuallyManaged, and Borrowed.
                only Owned HandleOwners can destroy the handles
                ManuallyManaged is used for things that are allocated and should be manually freed.
                Everything derefs to Borrowed, which is also where most method implementations are
        Note: It would be nice in future to think of a better name than HandleOwner, since they do not necessarily "own" the handle anymore

- [partial] consider proper lifetimes more for creating and allocating where the passed in parameters such as "CreateInfo" structs
        pass handles that should also be borrowed by the created HandleOwner (such as in allocate_descriptor_sets)
        - can now have public lifetime (which we want to borrow through structures), and private lifetime (which should only be borrowed
        within a struct). This allows lifetimes when creating and allocating, and maybe some other places, to properly borrow necessary things
        such as handles, and also ensure that the borrowing is not to limiting by not unnecessarily borrowing
        - TODO - still need to consider if all times are correct, such as AllocationCallbacks

- [x] fix struct generator macros
        right now, the macros are really awkward to use because .into() doesn't play nice with all types (especially numbers)
        also there are issues with creating references to temporary values being created (such as with &[] inside the macro call)
        this is not so bad for now.
        I will continue to use this and see if i can try it in a test project

- [x] EXT_debug_utils_loader doesn't generate the proper loading commands for some reason
        this needs to be fixed in order to ever use the debug extesion (maybe other extension have same problemaybe other extension have same problem)
        LOL, my bad. I had intentionall excluded generating command loaders for EXT_debug_utils for some reason.
        I don't remeber why so I just removed this exclusion

- [x] Remove old needs_lifetime from global_data - being replaced by type_lifetimes
        - TODO - deal with unions, seems there are no current examples of a union that would need a lifetime anyway

- [x] NEED TO FIX COMMMANDS WHICH RETURN STRUCTS WITH P_NEXT
        I assumed before that a struct with p_next would be filled in by the vulkan implementation. However, this is wrong, and the user
        needs to provide the struct with the pNext chain already built.
        -- OLD -- Need to provide api that cat take user provided destination, and return the destination initialized
        Solution: made fuctions whcih return to p_next chains generic over the types that can be in the p_next chain

- [x] Some extensions should only be supported if the Vulkan feature level is supported
        need to prevent loading extension commands that are unsupported by requested feature level

- [x] Some device extensions also load some instance level commands - this should be split to simplify safty
        In order to avoid issues with loading instance commands along with device level extensions when the instance might be shared
        we should just force the user to also load the device level extention when creating the instance and device seperatly

- [x] Add anti duplicate code to the ExtensionList traits
        The trait such as Contains, uses an index generic type, which is only implemented with unameable types
        if there are duplicates in the list, the index generic type must be manutally specified, but this is not possible
        due to the "unabmablility" of the index types, and because the Contains trait is also unamable.
        Thus, the user can only ever provide a list with no duplicates since they can never make the compiler happy if there are
        suplicates

- [ ] Add documentation for the extension traits because they are very weird
        Note: really everything shuld get some documentation, but this is a priority

========= LONG TERM GOALS (not blocking for MVP) ==================

- [ ] When GAT is available, I want to make commands that return array like data generic and user configurable over different array like
        containers such as Vec and static Array. This will allow the user to choose if the this library uses heap or stack storage.
        For now, everything just returns a Vec
        If we can also get some form of default type parameter for functions, then we can even make this change non breaking
        but it would otherwise be a breaking change as users will need to specify the return type everywhere.

- [ ] Make HandleOwners that do not need to store parent ref or commands (ABI compatible with raw handle array). This may be a pipe dream goal.
        Some design wherein staticly known memory locations are used for parent refs and commands has been considered, but it is very linmiting
        since you would need to hard code every possible VkDevice (and maybe even all types you plan to use). Maybe make it
        optional, it may be helpful in uses cases where hardware is alrady known and many things can be made static.

- [ ] Support custom allocators. The current implementation simply ignores any user provided custom allocator
        It is not necessary to support this now as it should be possible to add later without any breaking change
        and I do not care about custom allocators at this time
        Also, maybe custom allocators can be related to the above GAT related code??


PROBLEM

The the output of vkxml (based on https://github.com/NicolBolas/New-Vulkan-XML-Format) generates an
incomplete version of the spec (despite how they advertise)

For now I have a work around to use vk-parse out put directly to make aliases properly, and will also
need this for generating all enums properly (in the case wherethe enum was promoted from an extension
to a core feature, the extension number and offset are moved in the spec to the Feature definitions).
There are probably other situations where information is incomplete.

In the long run, it will probably be best to have an initial parseing stage based on the vk spes own
python parser in order to generate the data I need. Then this can be further parsed with my rust code.
This will take substantail amounts of work and re orginizing of the code to work.

Or not. yolo
